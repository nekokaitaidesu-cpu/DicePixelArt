<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Dice Pixel Art Editor</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { background: #1a1a2e; color: #eee; font-family: 'Segoe UI', sans-serif; display: flex; flex-direction: column; height: 100dvh; overflow: hidden; user-select: none; }

  #toolbar {
    background: #16213e;
    border-bottom: 1px solid #0f3460;
    padding: 6px 8px;
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    align-items: center;
    flex-shrink: 0;
    z-index: 10;
  }

  .tool-group {
    display: flex;
    align-items: center;
    gap: 4px;
    border-right: 1px solid #0f3460;
    padding-right: 8px;
  }
  .tool-group:last-child { border-right: none; }

  .tool-label {
    font-size: 10px;
    color: #888;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    white-space: nowrap;
  }

  button {
    background: #0f3460;
    color: #eee;
    border: 1px solid #1a5276;
    border-radius: 4px;
    padding: 4px 8px;
    cursor: pointer;
    font-size: 12px;
    transition: background 0.15s;
    white-space: nowrap;
  }
  button:hover { background: #1a5276; }
  button.active { background: #e94560; border-color: #e94560; color: #fff; }

  .color-btn {
    width: 28px; height: 28px;
    border-radius: 4px;
    display: flex; align-items: center; justify-content: center;
    font-size: 16px;
    padding: 0;
  }
  .color-btn.c-b { background: #fff; color: #222222; border: 2px solid #555; }
  .color-btn.c-r { background: #fff; color: #c0392b; border: 2px solid #555; }
  .color-btn.c-w { background: #222; color: #ffffff; border: 2px solid #555; }
  .color-btn.c-k { background: #222; color: #c0392b; border: 2px solid #555; }
  .color-btn.active { border: 2px solid #e94560 !important; }

  .pip-btn {
    width: 28px; height: 28px;
    padding: 0;
    font-size: 13px;
    font-weight: bold;
  }

  #canvas-wrap {
    flex: 1;
    overflow: hidden;
    position: relative;
    cursor: crosshair;
    background: #0d0d1a;
  }
  #canvas-wrap.panning { cursor: grab; }
  #canvas-wrap.panning.dragging { cursor: grabbing; }

  #main-canvas { position: absolute; top: 0; left: 0; }

  #size-input {
    width: 40px;
    background: #0f3460;
    color: #eee;
    border: 1px solid #1a5276;
    border-radius: 4px;
    padding: 3px 5px;
    font-size: 12px;
    text-align: center;
  }

  #status-bar {
    background: #16213e;
    border-top: 1px solid #0f3460;
    padding: 2px 8px;
    font-size: 10px;
    color: #888;
    display: flex;
    gap: 16px;
    flex-shrink: 0;
  }

  /* Modal for JSON load */
  #modal-overlay {
    display: none;
    position: fixed; inset: 0;
    background: rgba(0,0,0,0.7);
    z-index: 100;
    align-items: center;
    justify-content: center;
  }
  #modal-overlay.show { display: flex; }
  #modal-box {
    background: #16213e;
    border: 1px solid #0f3460;
    border-radius: 8px;
    padding: 20px;
    width: 90%;
    max-width: 500px;
  }
  #modal-box h3 { margin-bottom: 10px; }
  #modal-textarea {
    width: 100%; height: 200px;
    background: #0d0d1a;
    color: #eee;
    border: 1px solid #1a5276;
    border-radius: 4px;
    padding: 8px;
    font-family: monospace;
    font-size: 12px;
    resize: vertical;
  }
  #modal-btns { display: flex; gap: 8px; margin-top: 10px; justify-content: flex-end; }
</style>
</head>
<body>

<div id="toolbar">
  <!-- Color -->
  <div class="tool-group">
    <span class="tool-label">Ëâ≤</span>
    <button class="color-btn c-b active" data-color="b" title="ÁôΩÂú∞„ÉªÈªíÁÇπ">‚öÄ</button>
    <button class="color-btn c-r" data-color="r" title="ÁôΩÂú∞„ÉªËµ§ÁÇπ">‚öÄ</button>
    <button class="color-btn c-w" data-color="w" title="ÈªíÂú∞„ÉªÁôΩÁÇπ">‚öÄ</button>
    <button class="color-btn c-k" data-color="k" title="ÈªíÂú∞„ÉªËµ§ÁÇπ">‚öÄ</button>
  </div>

  <!-- Pip -->
  <div class="tool-group">
    <span class="tool-label">ÁõÆ</span>
    <button class="pip-btn active" data-pip="1" title="1„ÅÆÁõÆ">1</button>
    <button class="pip-btn" data-pip="2">2</button>
    <button class="pip-btn" data-pip="3">3</button>
    <button class="pip-btn" data-pip="4">4</button>
    <button class="pip-btn" data-pip="5">5</button>
    <button class="pip-btn" data-pip="6">6</button>
    <button class="pip-btn" data-pip="0" title="Ê∂à„Åó„Ç¥„É†">‚úï</button>
  </div>

  <!-- Tool mode -->
  <div class="tool-group">
    <span class="tool-label">„ÉÑ„Éº„É´</span>
    <button id="btn-pencil" class="active" title="ÈâõÁ≠Ü">‚úèÔ∏è</button>
    <button id="btn-pan" title="ÁßªÂãï">‚úã</button>
    <button id="btn-select" title="ÁØÑÂõ≤ÈÅ∏Êäû">‚¨ö</button>
  </div>

  <!-- Selection actions (shown when selection active) -->
  <div class="tool-group" id="sel-actions" style="display:none;">
    <span class="tool-label">ÈÅ∏Êäû</span>
    <button id="btn-sel-delete" title="ÈÅ∏ÊäûÁØÑÂõ≤„ÇíÂâäÈô§" style="color:#e74c3c;">‚úïÂâäÈô§</button>
    <button id="btn-sel-copy" title="ÈÅ∏ÊäûÁØÑÂõ≤„Çí„Ç≥„Éî„Éº">üìã„Ç≥„Éî„Éº</button>
    <button id="btn-sel-paste" title="Ë≤º„Çä‰ªò„Åë" style="display:none;">üìåË≤º‰ªò</button>
  </div>

  <!-- Undo -->
  <div class="tool-group">
    <button id="btn-undo" title="ÂÖÉ„Å´Êàª„Åô (Ctrl+Z)">‚Ü© Êàª„Çã</button>
  </div>

  <!-- Zoom -->
  <div class="tool-group">
    <span class="tool-label">„Ç∫„Éº„É†</span>
    <button id="btn-zoom-in">Ôºã</button>
    <button id="btn-zoom-out">Ôºç</button>
    <button id="btn-zoom-reset">1:1</button>
    <button id="btn-zoom-fit">ÂÖ®‰Ωì</button>
  </div>

  <!-- Grid size -->
  <div class="tool-group">
    <span class="tool-label">„Ç∞„É™„ÉÉ„Éâ</span>
    <input type="number" id="input-cols" class="size-input" value="60" min="5" max="200" title="ÂàóÊï∞">
    <span style="font-size:11px;color:#888;">√ó</span>
    <input type="number" id="input-rows" class="size-input" value="60" min="5" max="200" title="Ë°åÊï∞">
    <button id="btn-apply-size">ÈÅ©Áî®</button>
  </div>

  <!-- Background -->
  <div class="tool-group">
    <span class="tool-label">ËÉåÊôØ</span>
    <button class="bg-btn active" data-bg="checker" title="„Çø„Ç§„É´„Éû„ÇπÁõÆ">‚ñ¶</button>
    <button class="bg-btn" data-bg="black" title="Áúü„Å£Èªí" style="background:#000;color:#fff;border-color:#444;">‚ñ†</button>
    <button class="bg-btn" data-bg="white" title="Áúü„Å£ÁôΩ" style="background:#fff;color:#000;border-color:#aaa;">‚ñ°</button>
  </div>

  <!-- Save/Load -->
  <div class="tool-group">
    <span class="tool-label">‰øùÂ≠ò</span>
    <button id="btn-save-png">PNG</button>
    <button id="btn-save-json">JSON‰øùÂ≠ò</button>
    <button id="btn-load-json">JSONË™≠Ëæº</button>
    <button id="btn-clear" style="color:#e74c3c;">ÂÖ®Ê∂àÂéª</button>
  </div>
</div>

<div id="canvas-wrap">
  <canvas id="main-canvas"></canvas>
</div>

<div id="status-bar">
  <span id="status-cursor">„Ç´„Éº„ÇΩ„É´: -</span>
  <span id="status-zoom">„Ç∫„Éº„É†: 100%</span>
  <span id="status-grid">„Ç∞„É™„ÉÉ„Éâ: 60√ó60</span>
  <span id="status-tip">Space+„Éâ„É©„ÉÉ„Ç∞ or ‰∏≠„Éú„Çø„É≥: „Éë„É≥ | „Éõ„Ç§„Éº„É´: „Ç∫„Éº„É† | 2/3/6„ÅÆÁõÆ„ÇíÂÜç„ÇØ„É™„ÉÉ„ÇØ: Âêë„ÅçÂ§âÊõ¥</span>
</div>

<!-- JSON Load Modal -->
<div id="modal-overlay">
  <div id="modal-box">
    <h3>JSON„Éá„Éº„Çø„ÇíË≤º„Çä‰ªò„Åë</h3>
    <textarea id="modal-textarea" placeholder='{"version":1,"cols":60,"rows":60,"grid":[[...],...]}' spellcheck="false"></textarea>
    <div id="modal-btns">
      <button id="modal-cancel">„Ç≠„É£„É≥„Çª„É´</button>
      <button id="modal-ok" style="background:#27ae60;border-color:#27ae60;">Ë™≠„ÅøËæº„ÇÄ</button>
    </div>
  </div>
</div>

<script>
'use strict';

// ====== State ======
const STATE = {
  cols: 60,
  rows: 60,
  grid: null,       // 2D array [row][col] = "b1"|"r3"|null
  color: 'b',       // 'b' or 'r'
  pip: 1,           // 1-6, 0=eraser
  tool: 'pencil',   // 'pencil' | 'pan' | 'select'
  bg: 'checker',    // 'checker' | 'black' | 'white'
  // History (undo)
  history: [],      // array of grid snapshots
  historyPushed: false, // guard: push only once per stroke
  // Selection
  selRect: null,    // {c1,r1,c2,r2} normalized grid coords, or null
  selDragging: false,
  selDragC1: 0, selDragR1: 0,
  selDragC2: 0, selDragR2: 0,
  clipboard: null,  // 2D array (rows√ócols) of cell values
  // Viewport
  offsetX: 0,
  offsetY: 0,
  scale: 1,
  // Interaction
  isPainting: false,
  isPanning: false,
  panStartX: 0,
  panStartY: 0,
  panStartOX: 0,
  panStartOY: 0,
  spaceDown: false,
  lastPaintCol: -1,
  lastPaintRow: -1,
  // Touch
  touches: [],
  lastPinchDist: 0,
};

function initGrid(cols, rows) {
  const g = [];
  for (let r = 0; r < rows; r++) {
    g.push(new Array(cols).fill(null));
  }
  return g;
}

STATE.grid = initGrid(STATE.cols, STATE.rows);

// ====== Canvas Setup ======
const wrap = document.getElementById('canvas-wrap');
const canvas = document.getElementById('main-canvas');
const ctx = canvas.getContext('2d');

function resizeCanvas() {
  canvas.width = wrap.clientWidth;
  canvas.height = wrap.clientHeight;
  render();
}

window.addEventListener('resize', resizeCanvas);

// ====== Orientation cycling ======
// pips that support orientation variants, with their cycle order
const ORIENT_CYCLES = {
  2: ['', 'f'],   // default(‚Üò) ‚Üí flipped(‚Üô)
  3: ['', 'f'],   // default(‚Üò) ‚Üí flipped(‚Üô)
  6: ['', 'r'],   // default(Á∏¶) ‚Üí rotated(Ê®™)
};

// Try to cycle orientation of the cell if it matches current color+pip.
// Returns true if cycled (so caller shouldn't start a fresh paint).
function tryOrientCycle(col, row) {
  if (col < 0 || col >= STATE.cols || row < 0 || row >= STATE.rows) return false;
  if (STATE.pip === 0) return false;
  const current = STATE.grid[row][col];
  if (!current) return false;
  const cellColor = current[0];
  const cellPip   = parseInt(current[1]);
  if (cellColor !== STATE.color || cellPip !== STATE.pip) return false;
  const cycle = ORIENT_CYCLES[cellPip];
  if (!cycle) return false;
  const cellVariant = current.slice(2);
  const idx = cycle.indexOf(cellVariant);
  const nextVariant = cycle[(idx + 1) % cycle.length];
  pushHistory();
  STATE.grid[row][col] = `${cellColor}${cellPip}${nextVariant}`;
  autoSave();
  render();
  return true;
}

// ====== History (Undo) ======
const MAX_HISTORY = 50;

function pushHistory() {
  const snapshot = STATE.grid.map(r => [...r]);
  STATE.history.push(snapshot);
  if (STATE.history.length > MAX_HISTORY) STATE.history.shift();
  document.getElementById('btn-undo').disabled = false;
}

function undo() {
  if (!STATE.history.length) return;
  STATE.grid = STATE.history.pop().map(r => [...r]);
  if (!STATE.history.length) document.getElementById('btn-undo').disabled = true;
  STATE.selRect = null;
  updateSelActions();
  autoSave();
  render();
}

// ====== Selection helpers ======
function normalizeSelRect(c1, r1, c2, r2) {
  return {
    c1: Math.max(0, Math.min(c1, c2)),
    r1: Math.max(0, Math.min(r1, r2)),
    c2: Math.min(STATE.cols - 1, Math.max(c1, c2)),
    r2: Math.min(STATE.rows - 1, Math.max(r1, r2)),
  };
}

function updateSelActions() {
  const hasSel = !!STATE.selRect;
  const hasClip = !!STATE.clipboard;
  document.getElementById('sel-actions').style.display = (hasSel || hasClip) ? '' : 'none';
  document.getElementById('btn-sel-delete').style.display = hasSel ? '' : 'none';
  document.getElementById('btn-sel-copy').style.display   = hasSel ? '' : 'none';
  document.getElementById('btn-sel-paste').style.display  = hasClip ? '' : 'none';
}

function selDelete() {
  if (!STATE.selRect) return;
  pushHistory();
  const { c1, r1, c2, r2 } = STATE.selRect;
  for (let r = r1; r <= r2; r++)
    for (let c = c1; c <= c2; c++)
      STATE.grid[r][c] = null;
  STATE.selRect = null;
  updateSelActions();
  autoSave();
  render();
}

function selCopy() {
  if (!STATE.selRect) return;
  const { c1, r1, c2, r2 } = STATE.selRect;
  STATE.clipboard = [];
  for (let r = r1; r <= r2; r++) {
    const row = [];
    for (let c = c1; c <= c2; c++) row.push(STATE.grid[r][c]);
    STATE.clipboard.push(row);
  }
  updateSelActions();
}

function selPaste() {
  if (!STATE.clipboard) return;
  pushHistory();
  // Paste at selection origin if present, else top-left of visible area
  let destC = 0, destR = 0;
  if (STATE.selRect) {
    destC = STATE.selRect.c1;
    destR = STATE.selRect.r1;
  } else {
    const cs = cellSize();
    destC = Math.max(0, Math.floor(-STATE.offsetX / cs));
    destR = Math.max(0, Math.floor(-STATE.offsetY / cs));
  }
  const clipRows = STATE.clipboard.length;
  const clipCols = STATE.clipboard[0].length;
  for (let r = 0; r < clipRows; r++) {
    const gr = destR + r;
    if (gr >= STATE.rows) break;
    for (let c = 0; c < clipCols; c++) {
      const gc = destC + c;
      if (gc >= STATE.cols) break;
      STATE.grid[gr][gc] = STATE.clipboard[r][c];
    }
  }
  // Set selection to pasted area
  STATE.selRect = normalizeSelRect(
    destC, destR,
    Math.min(STATE.cols - 1, destC + clipCols - 1),
    Math.min(STATE.rows - 1, destR + clipRows - 1)
  );
  updateSelActions();
  autoSave();
  render();
}

// ====== Background helpers ======
function emptyColor(r, c) {
  if (STATE.bg === 'black') return '#000000';
  if (STATE.bg === 'white') return '#ffffff';
  // checker
  return (r + c) % 2 === 0 ? '#1a1a2e' : '#16213e';
}
function emptyColorExport(r, c) {
  if (STATE.bg === 'black') return '#000000';
  if (STATE.bg === 'white') return '#ffffff';
  // checker (slightly lighter for export readability)
  return (r + c) % 2 === 0 ? '#e8e8e8' : '#d0d0d0';
}

// ====== Rendering ======
const CELL = 16; // base cell size in px

function cellSize() {
  return Math.max(2, Math.round(CELL * STATE.scale));
}

function render() {
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0, 0, W, H);

  // Background
  ctx.fillStyle = '#111';
  ctx.fillRect(0, 0, W, H);

  const cs = cellSize();
  const ox = STATE.offsetX, oy = STATE.offsetY;

  // Visible range
  const colStart = Math.max(0, Math.floor(-ox / cs));
  const rowStart = Math.max(0, Math.floor(-oy / cs));
  const colEnd   = Math.min(STATE.cols, Math.ceil((W - ox) / cs) + 1);
  const rowEnd   = Math.min(STATE.rows, Math.ceil((H - oy) / cs) + 1);

  // Draw cells
  for (let r = rowStart; r < rowEnd; r++) {
    for (let c = colStart; c < colEnd; c++) {
      const x = ox + c * cs;
      const y = oy + r * cs;
      const val = STATE.grid[r][c];

      if (val) {
        drawDiceCell(ctx, x, y, cs, val);
      } else {
        ctx.fillStyle = emptyColor(r, c);
        ctx.fillRect(x, y, cs, cs);
      }
    }
  }

  // Grid lines (only when big enough)
  if (cs >= 6) {
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.lineWidth = 0.5;
    const step = cs >= 3 ? cs : cs * 2;

    ctx.beginPath();
    for (let c = colStart; c <= colEnd; c++) {
      const x = ox + c * cs + 0.5;
      ctx.moveTo(x, oy + rowStart * cs);
      ctx.lineTo(x, oy + rowEnd * cs);
    }
    for (let r = rowStart; r <= rowEnd; r++) {
      const y = oy + r * cs + 0.5;
      ctx.moveTo(ox + colStart * cs, y);
      ctx.lineTo(ox + colEnd * cs, y);
    }
    ctx.stroke();
  }

  // Border around whole grid
  ctx.strokeStyle = 'rgba(255,255,255,0.3)';
  ctx.lineWidth = 1;
  ctx.strokeRect(ox + 0.5, oy + 0.5, STATE.cols * cs - 1, STATE.rows * cs - 1);

  // Selection overlay
  const sr = STATE.selDragging
    ? normalizeSelRect(STATE.selDragC1, STATE.selDragR1, STATE.selDragC2, STATE.selDragR2)
    : STATE.selRect;
  if (sr) {
    const sx = ox + sr.c1 * cs;
    const sy2 = oy + sr.r1 * cs;
    const sw = (sr.c2 - sr.c1 + 1) * cs;
    const sh = (sr.r2 - sr.r1 + 1) * cs;
    ctx.fillStyle = 'rgba(100,180,255,0.15)';
    ctx.fillRect(sx, sy2, sw, sh);
    ctx.strokeStyle = '#4af';
    ctx.lineWidth = 1.5;
    ctx.setLineDash([4, 3]);
    ctx.strokeRect(sx + 0.5, sy2 + 0.5, sw - 1, sh - 1);
    ctx.setLineDash([]);
  }
}

// Draw a single dice cell
function drawDiceCell(ctx, x, y, cs, val) {
  const color   = val[0];           // 'b' or 'r'
  const pip     = parseInt(val[1]); // 1-6
  const variant = val.slice(2);     // '', 'f', or 'r'

  const darkBg  = color === 'w' || color === 'k';
  const bgBase  = darkBg ? '#222222' : '#ffffff';
  const bgShade = darkBg ? '#1a1a1a' : '#f8f8f8';
  const pipColor =
    color === 'b' ? '#222222' :
    color === 'r' ? '#c0392b' :
    color === 'w' ? '#ffffff' :
    /* k */         '#c0392b';

  // Background
  ctx.fillStyle = bgBase;
  ctx.fillRect(x, y, cs, cs);

  // Rounded corners hint - only for larger cells
  if (cs >= 8) {
    const r = Math.max(1, cs * 0.1);
    roundRect(ctx, x, y, cs, cs, r);
    ctx.fillStyle = bgShade;
    ctx.fill();
  }

  drawPips(ctx, x, y, cs, pip, variant, pipColor);
}

function roundRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
}

// Pip positions: normalized [x,y] in [0,1] for each face + variant
// key = pip number (as string) + variant suffix ('', 'f', 'r')
const PIP_LAYOUTS = {
  '1':  [[0.5, 0.5]],
  // 2: default = top-left ‚Üí bottom-right diagonal
  '2':  [[0.25, 0.25], [0.75, 0.75]],
  // 2f: flipped = top-right ‚Üí bottom-left diagonal
  '2f': [[0.75, 0.25], [0.25, 0.75]],
  // 3: same diagonal as 2 + center
  '3':  [[0.25, 0.25], [0.5, 0.5], [0.75, 0.75]],
  // 3f: flipped diagonal + center
  '3f': [[0.75, 0.25], [0.5, 0.5], [0.25, 0.75]],
  '4':  [[0.25, 0.25], [0.75, 0.25], [0.25, 0.75], [0.75, 0.75]],
  '5':  [[0.25, 0.25], [0.75, 0.25], [0.5, 0.5], [0.25, 0.75], [0.75, 0.75]],
  // 6: default = vertical (2 cols √ó 3 rows)
  '6':  [[0.25, 0.22], [0.75, 0.22], [0.25, 0.5], [0.75, 0.5], [0.25, 0.78], [0.75, 0.78]],
  // 6r: rotated = horizontal (3 cols √ó 2 rows)
  '6r': [[0.22, 0.25], [0.5, 0.25], [0.78, 0.25], [0.22, 0.75], [0.5, 0.75], [0.78, 0.75]],
};

function drawPips(ctx, x, y, cs, pip, variant, color) {
  if (!pip || pip < 1 || pip > 6) return;
  const key = `${pip}${variant}`;
  const positions = PIP_LAYOUTS[key] || PIP_LAYOUTS[`${pip}`];
  const pipR = Math.max(1, cs * 0.1);

  ctx.fillStyle = color;
  for (const [nx, ny] of positions) {
    const px = x + nx * cs;
    const py = y + ny * cs;
    ctx.beginPath();
    ctx.arc(px, py, pipR, 0, Math.PI * 2);
    ctx.fill();
  }
}

// ====== Viewport helpers ======
function screenToGrid(sx, sy) {
  const cs = cellSize();
  const col = Math.floor((sx - STATE.offsetX) / cs);
  const row = Math.floor((sy - STATE.offsetY) / cs);
  return { col, row };
}

function clampViewport() {
  const cs = cellSize();
  const W = canvas.width, H = canvas.height;
  const gw = STATE.cols * cs, gh = STATE.rows * cs;
  // Allow some overshoot (half viewport)
  STATE.offsetX = Math.min(W * 0.5, Math.max(W * 0.5 - gw, STATE.offsetX));
  STATE.offsetY = Math.min(H * 0.5, Math.max(H * 0.5 - gh, STATE.offsetY));
}

function zoomAround(factor, cx, cy) {
  const oldScale = STATE.scale;
  STATE.scale = Math.min(16, Math.max(0.1, STATE.scale * factor));
  const sf = STATE.scale / oldScale;
  STATE.offsetX = cx - sf * (cx - STATE.offsetX);
  STATE.offsetY = cy - sf * (cy - STATE.offsetY);
  clampViewport();
  updateStatus();
  render();
}

function fitToScreen() {
  const W = canvas.width, H = canvas.height;
  const margin = 20;
  const scaleX = (W - margin * 2) / (STATE.cols * CELL);
  const scaleY = (H - margin * 2) / (STATE.rows * CELL);
  STATE.scale = Math.min(scaleX, scaleY, 1);
  const cs = cellSize();
  STATE.offsetX = Math.round((W - STATE.cols * cs) / 2);
  STATE.offsetY = Math.round((H - STATE.rows * cs) / 2);
  updateStatus();
  render();
}

function resetZoom() {
  STATE.scale = 1;
  const W = canvas.width, H = canvas.height;
  const cs = cellSize();
  STATE.offsetX = Math.round((W - STATE.cols * cs) / 2);
  STATE.offsetY = Math.round((H - STATE.rows * cs) / 2);
  updateStatus();
  render();
}

// ====== Paint ======
function paintAt(col, row) {
  if (col < 0 || col >= STATE.cols || row < 0 || row >= STATE.rows) return;
  if (col === STATE.lastPaintCol && row === STATE.lastPaintRow) return;
  STATE.lastPaintCol = col;
  STATE.lastPaintRow = row;

  // Push history once per stroke (before first change)
  if (!STATE.historyPushed) { pushHistory(); STATE.historyPushed = true; }

  // Always place with default variant when painting (dragging)
  const val = STATE.pip === 0 ? null : `${STATE.color}${STATE.pip}`;
  STATE.grid[row][col] = val;
  autoSave();
  render();
}

// ====== Mouse Events ======
wrap.addEventListener('mousedown', (e) => {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const sx = e.clientX - rect.left;
  const sy = e.clientY - rect.top;

  const panMode = STATE.tool === 'pan' || STATE.spaceDown || e.button === 1;

  if (panMode) {
    STATE.isPanning = true;
    STATE.panStartX = e.clientX;
    STATE.panStartY = e.clientY;
    STATE.panStartOX = STATE.offsetX;
    STATE.panStartOY = STATE.offsetY;
    wrap.classList.add('dragging');
  } else if (STATE.tool === 'select' && e.button === 0) {
    const { col, row } = screenToGrid(sx, sy);
    STATE.selDragging = true;
    STATE.selDragC1 = col; STATE.selDragR1 = row;
    STATE.selDragC2 = col; STATE.selDragR2 = row;
    STATE.selRect = null;
    updateSelActions();
    render();
  } else if (e.button === 0) {
    STATE.isPainting = true;
    STATE.historyPushed = false;
    const { col, row } = screenToGrid(sx, sy);
    if (tryOrientCycle(col, row)) {
      // cycled orientation ‚Äì mark cell as visited so drag doesn't re-paint it
      STATE.lastPaintCol = col;
      STATE.lastPaintRow = row;
    } else {
      STATE.lastPaintCol = -1;
      STATE.lastPaintRow = -1;
      paintAt(col, row);
    }
  }
});

window.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  const sx = e.clientX - rect.left;
  const sy = e.clientY - rect.top;

  if (STATE.isPanning) {
    STATE.offsetX = STATE.panStartOX + e.clientX - STATE.panStartX;
    STATE.offsetY = STATE.panStartOY + e.clientY - STATE.panStartY;
    clampViewport();
    render();
  } else if (STATE.selDragging) {
    const { col, row } = screenToGrid(sx, sy);
    STATE.selDragC2 = col; STATE.selDragR2 = row;
    render();
  } else if (STATE.isPainting) {
    const { col, row } = screenToGrid(sx, sy);
    paintAt(col, row);
  }

  // Update cursor status
  const { col, row } = screenToGrid(sx, sy);
  if (col >= 0 && col < STATE.cols && row >= 0 && row < STATE.rows) {
    document.getElementById('status-cursor').textContent = `„Ç´„Éº„ÇΩ„É´: (${col+1}, ${row+1})`;
  } else {
    document.getElementById('status-cursor').textContent = '„Ç´„Éº„ÇΩ„É´: -';
  }
});

window.addEventListener('mouseup', (e) => {
  if (STATE.selDragging) {
    STATE.selDragging = false;
    STATE.selRect = normalizeSelRect(
      STATE.selDragC1, STATE.selDragR1,
      STATE.selDragC2, STATE.selDragR2
    );
    updateSelActions();
    render();
  }
  STATE.isPanning = false;
  STATE.isPainting = false;
  STATE.historyPushed = false;
  wrap.classList.remove('dragging');
});

wrap.addEventListener('wheel', (e) => {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const cx = e.clientX - rect.left;
  const cy = e.clientY - rect.top;
  const factor = e.deltaY < 0 ? 1.15 : 1 / 1.15;
  zoomAround(factor, cx, cy);
}, { passive: false });

// Keyboard shortcuts
window.addEventListener('keydown', (e) => {
  if (e.target.matches('input, textarea')) return;
  if (e.code === 'Space') {
    STATE.spaceDown = true;
    wrap.classList.add('panning');
    e.preventDefault();
  }
  if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
    e.preventDefault();
    undo();
  }
  if (e.code === 'Escape' && STATE.tool === 'select') {
    STATE.selRect = null;
    STATE.selDragging = false;
    updateSelActions();
    render();
  }
  if (e.code === 'Delete' && STATE.selRect) {
    selDelete();
  }
});
window.addEventListener('keyup', (e) => {
  if (e.code === 'Space') {
    STATE.spaceDown = false;
    if (STATE.tool !== 'pan') wrap.classList.remove('panning');
  }
});

// Prevent middle-click scroll
wrap.addEventListener('auxclick', (e) => { if (e.button === 1) e.preventDefault(); });

// ====== Touch Events ======
wrap.addEventListener('touchstart', (e) => {
  e.preventDefault();
  STATE.touches = Array.from(e.touches);
  if (STATE.touches.length === 2) {
    STATE.lastPinchDist = pinchDist(STATE.touches);
    STATE.isPainting = false;
    // start pan reference
    const mid = pinchMid(STATE.touches, canvas.getBoundingClientRect());
    STATE.panStartX = mid.x;
    STATE.panStartY = mid.y;
    STATE.panStartOX = STATE.offsetX;
    STATE.panStartOY = STATE.offsetY;
  } else if (STATE.touches.length === 1) {
    const rect = canvas.getBoundingClientRect();
    const t = STATE.touches[0];
    const sx = t.clientX - rect.left;
    const sy = t.clientY - rect.top;
    if (STATE.tool === 'pan') {
      STATE.isPanning = true;
      STATE.panStartX = t.clientX;
      STATE.panStartY = t.clientY;
      STATE.panStartOX = STATE.offsetX;
      STATE.panStartOY = STATE.offsetY;
    } else {
      STATE.isPainting = true;
      const { col, row } = screenToGrid(sx, sy);
      if (tryOrientCycle(col, row)) {
        STATE.lastPaintCol = col;
        STATE.lastPaintRow = row;
      } else {
        STATE.lastPaintCol = -1;
        STATE.lastPaintRow = -1;
        paintAt(col, row);
      }
    }
  }
}, { passive: false });

wrap.addEventListener('touchmove', (e) => {
  e.preventDefault();
  const touches = Array.from(e.touches);
  const rect = canvas.getBoundingClientRect();

  if (touches.length === 2) {
    const dist = pinchDist(touches);
    const factor = dist / STATE.lastPinchDist;
    STATE.lastPinchDist = dist;
    const mid = pinchMid(touches, rect);
    // Pan
    STATE.offsetX = STATE.panStartOX + mid.x - STATE.panStartX;
    STATE.offsetY = STATE.panStartOY + mid.y - STATE.panStartY;
    // Zoom around midpoint
    const oldScale = STATE.scale;
    STATE.scale = Math.min(16, Math.max(0.1, STATE.scale * factor));
    const sf = STATE.scale / oldScale;
    STATE.offsetX = mid.x - sf * (mid.x - STATE.offsetX);
    STATE.offsetY = mid.y - sf * (mid.y - STATE.offsetY);
    clampViewport();
    updateStatus();
    render();
  } else if (touches.length === 1) {
    const t = touches[0];
    if (STATE.isPanning) {
      STATE.offsetX = STATE.panStartOX + t.clientX - STATE.panStartX;
      STATE.offsetY = STATE.panStartOY + t.clientY - STATE.panStartY;
      clampViewport();
      render();
    } else if (STATE.isPainting) {
      const sx = t.clientX - rect.left;
      const sy = t.clientY - rect.top;
      const { col, row } = screenToGrid(sx, sy);
      paintAt(col, row);
    }
  }
}, { passive: false });

wrap.addEventListener('touchend', (e) => {
  STATE.touches = Array.from(e.touches);
  if (STATE.touches.length === 0) {
    STATE.isPanning = false;
    STATE.isPainting = false;
  }
}, { passive: false });

function pinchDist(ts) {
  const dx = ts[0].clientX - ts[1].clientX;
  const dy = ts[0].clientY - ts[1].clientY;
  return Math.sqrt(dx * dx + dy * dy);
}
function pinchMid(ts, rect) {
  return {
    x: (ts[0].clientX + ts[1].clientX) / 2 - rect.left,
    y: (ts[0].clientY + ts[1].clientY) / 2 - rect.top,
  };
}

// ====== Toolbar Buttons ======
document.querySelectorAll('.color-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    STATE.color = btn.dataset.color;
    document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
  });
});

document.querySelectorAll('.pip-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    STATE.pip = parseInt(btn.dataset.pip);
    document.querySelectorAll('.pip-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    // Switch to pencil mode automatically
    if (STATE.pip !== 0) setTool('pencil');
  });
});

function setTool(tool) {
  STATE.tool = tool;
  document.getElementById('btn-pencil').classList.toggle('active', tool === 'pencil');
  document.getElementById('btn-pan').classList.toggle('active', tool === 'pan');
  document.getElementById('btn-select').classList.toggle('active', tool === 'select');
  wrap.classList.toggle('panning', tool === 'pan');
  wrap.style.cursor = tool === 'select' ? 'crosshair' : '';
  // Clear selection when leaving select tool
  if (tool !== 'select') {
    STATE.selRect = null;
    STATE.selDragging = false;
    updateSelActions();
    render();
  }
}

// Background buttons
document.querySelectorAll('.bg-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    STATE.bg = btn.dataset.bg;
    document.querySelectorAll('.bg-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    render();
  });
});

document.getElementById('btn-pencil').addEventListener('click', () => setTool('pencil'));
document.getElementById('btn-pan').addEventListener('click', () => setTool('pan'));
document.getElementById('btn-select').addEventListener('click', () => setTool('select'));

// Selection actions
document.getElementById('btn-sel-delete').addEventListener('click', selDelete);
document.getElementById('btn-sel-copy').addEventListener('click', selCopy);
document.getElementById('btn-sel-paste').addEventListener('click', selPaste);

// Undo
document.getElementById('btn-undo').addEventListener('click', undo);
document.getElementById('btn-undo').disabled = true;

document.getElementById('btn-zoom-in').addEventListener('click', () => {
  const cx = canvas.width / 2, cy = canvas.height / 2;
  zoomAround(1.5, cx, cy);
});
document.getElementById('btn-zoom-out').addEventListener('click', () => {
  const cx = canvas.width / 2, cy = canvas.height / 2;
  zoomAround(1 / 1.5, cx, cy);
});
document.getElementById('btn-zoom-reset').addEventListener('click', resetZoom);
document.getElementById('btn-zoom-fit').addEventListener('click', fitToScreen);

document.getElementById('btn-apply-size').addEventListener('click', () => {
  const newCols = parseInt(document.getElementById('input-cols').value);
  const newRows = parseInt(document.getElementById('input-rows').value);
  if (newCols < 5 || newCols > 200 || newRows < 5 || newRows > 200) {
    alert('„Ç∞„É™„ÉÉ„Éâ„Çµ„Ç§„Ç∫„ÅØ5„Äú200„ÅÆÁØÑÂõ≤„ÅßÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
    return;
  }
  if (!confirm(`„Ç∞„É™„ÉÉ„Éâ„Çí ${newCols}√ó${newRows} „Å´Â§âÊõ¥„Åó„Åæ„Åô„ÄÇÁèæÂú®„ÅÆÁµµ„ÅØ„É™„Çª„ÉÉ„Éà„Åï„Çå„Åæ„Åô„ÄÇ„Çà„Çç„Åó„ÅÑ„Åß„Åô„ÅãÔºü`)) return;
  STATE.cols = newCols;
  STATE.rows = newRows;
  STATE.grid = initGrid(newCols, newRows);
  autoSave();
  updateStatus();
  fitToScreen();
});

document.getElementById('btn-clear').addEventListener('click', () => {
  if (!confirm('„Åô„Åπ„Å¶Ê∂àÂéª„Åó„Åæ„Åô„ÅãÔºü')) return;
  pushHistory();
  STATE.grid = initGrid(STATE.cols, STATE.rows);
  autoSave();
  render();
});

// ====== Save / Load ======
document.getElementById('btn-save-png').addEventListener('click', savePng);
document.getElementById('btn-save-json').addEventListener('click', saveJson);
document.getElementById('btn-load-json').addEventListener('click', () => {
  document.getElementById('modal-overlay').classList.add('show');
  document.getElementById('modal-textarea').value = '';
  document.getElementById('modal-textarea').focus();
});

document.getElementById('modal-cancel').addEventListener('click', () => {
  document.getElementById('modal-overlay').classList.remove('show');
});
document.getElementById('modal-ok').addEventListener('click', () => {
  try {
    const data = JSON.parse(document.getElementById('modal-textarea').value);
    loadFromData(data);
    document.getElementById('modal-overlay').classList.remove('show');
  } catch (err) {
    alert('JSON„ÅÆËß£Êûê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ' + err.message);
  }
});

function savePng() {
  const EXPORT_CELL = 40;
  const W = STATE.cols * EXPORT_CELL;
  const H = STATE.rows * EXPORT_CELL;
  const offCanvas = document.createElement('canvas');
  offCanvas.width = W;
  offCanvas.height = H;
  const offCtx = offCanvas.getContext('2d');

  // Fill base background for solid modes
  offCtx.fillStyle = STATE.bg === 'black' ? '#000000' : STATE.bg === 'white' ? '#ffffff' : '#cccccc';
  offCtx.fillRect(0, 0, W, H);

  for (let r = 0; r < STATE.rows; r++) {
    for (let c = 0; c < STATE.cols; c++) {
      const val = STATE.grid[r][c];
      const x = c * EXPORT_CELL;
      const y = r * EXPORT_CELL;
      if (val) {
        drawDiceCell(offCtx, x, y, EXPORT_CELL, val);
      } else {
        offCtx.fillStyle = emptyColorExport(r, c);
        offCtx.fillRect(x, y, EXPORT_CELL, EXPORT_CELL);
      }
    }
  }

  // Grid lines
  offCtx.strokeStyle = 'rgba(0,0,0,0.15)';
  offCtx.lineWidth = 0.5;
  for (let c = 0; c <= STATE.cols; c++) {
    offCtx.beginPath();
    offCtx.moveTo(c * EXPORT_CELL + 0.5, 0);
    offCtx.lineTo(c * EXPORT_CELL + 0.5, H);
    offCtx.stroke();
  }
  for (let r = 0; r <= STATE.rows; r++) {
    offCtx.beginPath();
    offCtx.moveTo(0, r * EXPORT_CELL + 0.5);
    offCtx.lineTo(W, r * EXPORT_CELL + 0.5);
    offCtx.stroke();
  }

  const a = document.createElement('a');
  a.download = `dice-pixel-art-${STATE.cols}x${STATE.rows}.png`;
  a.href = offCanvas.toDataURL('image/png');
  a.click();
}

function getDataObj() {
  return {
    version: 1,
    cols: STATE.cols,
    rows: STATE.rows,
    grid: STATE.grid.map(row => row.map(v => v === null ? null : v)),
  };
}

function saveJson() {
  const data = getDataObj();
  const json = JSON.stringify(data);
  const blob = new Blob([json], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.download = `dice-pixel-art-${STATE.cols}x${STATE.rows}.json`;
  a.href = url;
  a.click();
  URL.revokeObjectURL(url);
}

function loadFromData(data) {
  if (!data.version || !data.cols || !data.rows || !data.grid) {
    throw new Error('‰∏çÊ≠£„Å™„Éá„Éº„ÇøÂΩ¢Âºè„Åß„Åô');
  }
  STATE.cols = data.cols;
  STATE.rows = data.rows;
  STATE.grid = data.grid;
  document.getElementById('input-cols').value = STATE.cols;
  document.getElementById('input-rows').value = STATE.rows;
  autoSave();
  updateStatus();
  fitToScreen();
}

// ====== AutoSave (LocalStorage) ======
const LS_KEY = 'dice-pixel-art-autosave';

function autoSave() {
  try {
    const data = getDataObj();
    localStorage.setItem(LS_KEY, JSON.stringify(data));
  } catch (e) { /* quota exceeded */ }
}

function autoLoad() {
  try {
    const raw = localStorage.getItem(LS_KEY);
    if (!raw) return false;
    const data = JSON.parse(raw);
    if (data.cols && data.rows && data.grid) {
      STATE.cols = data.cols;
      STATE.rows = data.rows;
      STATE.grid = data.grid;
      document.getElementById('input-cols').value = STATE.cols;
      document.getElementById('input-rows').value = STATE.rows;
      return true;
    }
  } catch (e) {}
  return false;
}

// ====== Status Bar ======
function updateStatus() {
  document.getElementById('status-zoom').textContent = `„Ç∫„Éº„É†: ${Math.round(STATE.scale * 100)}%`;
  document.getElementById('status-grid').textContent = `„Ç∞„É™„ÉÉ„Éâ: ${STATE.cols}√ó${STATE.rows}`;
}

// ====== Init ======
resizeCanvas();
if (autoLoad()) {
  fitToScreen();
} else {
  fitToScreen();
}
updateStatus();
</script>
</body>
</html>
